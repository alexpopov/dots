#!/bin/bash
# git-find-split: Find the commit where current branch diverged from upstream
#
# Strategies (in order):
# 1. PORE_FETCH_LAST_0 (pore repos)
# 2. static.xml manifest lookup (repo/pore trees)
# 3. Common upstream branches (regular git)
# 4. Fallback: HEAD~20

set -euo pipefail

# Find repo/pore tree root by walking up
find_tree_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.pore" ]] || [[ -d "$dir/.repo" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    return 1
}

# Get path relative to tree root
get_relative_path() {
    local tree_root="$1"
    local git_root
    git_root=$(git rev-parse --show-toplevel)
    echo "${git_root#$tree_root/}"
}

# Parse static.xml for project revision
# Assumes single-line XML elements like:
#   <project ... path="vendor/meta/tools/runway" revision="abc123" .../>
lookup_static_manifest() {
    local tree_root="$1"
    local project_path="$2"
    local static_xml=""

    # Try common locations for static manifest
    for candidate in \
        "$tree_root/.repo/manifests/static/static.xml" \
        "$tree_root/.pore/manifest/static/static.xml" \
        "$tree_root/.repo/manifest/static/static.xml"; do
        if [[ -f "$candidate" ]]; then
            static_xml="$candidate"
            break
        fi
    done

    [[ -z "$static_xml" ]] && return 1

    # Extract revision for matching path
    grep "path=\"$project_path\"" "$static_xml" 2>/dev/null | \
        sed -n 's/.*revision="\([^"]*\)".*/\1/p' | head -1
}

# Try merge-base with a ref
try_merge_base() {
    local ref="$1"
    git merge-base HEAD "$ref" 2>/dev/null
}

# Strategy 1: PORE ref
try_pore() {
    git rev-parse PORE_FETCH_LAST_0 2>/dev/null
}

# Strategy 2: repo/pore manifest lookup
try_manifest() {
    local tree_root project_path revision
    tree_root=$(find_tree_root) || return 1
    project_path=$(get_relative_path "$tree_root")
    revision=$(lookup_static_manifest "$tree_root" "$project_path") || return 1
    [[ -n "$revision" ]] && echo "$revision"
}

# Strategy 3: common upstream branches
try_upstream() {
    # Try common upstream branches
    for branch in origin/main origin/master upstream/main upstream/master main master; do
        if git rev-parse "$branch" &>/dev/null; then
            try_merge_base "$branch" && return 0
        fi
    done
    return 1
}

# Strategy 4: fallback to recent history
fallback() {
    git rev-parse HEAD~20 2>/dev/null || git rev-list --max-parents=0 HEAD | head -1
}

# Main
main() {
    # Early exit if not in a git repo
    if ! git rev-parse --git-dir &>/dev/null; then
        echo "fatal: not a git repository" >&2
        return 1
    fi

    local result

    if result=$(try_pore) && [[ -n "$result" ]]; then
        echo "$result"
        return 0
    fi

    if result=$(try_manifest) && [[ -n "$result" ]]; then
        echo "$result"
        return 0
    fi

    if result=$(try_upstream) && [[ -n "$result" ]]; then
        echo "$result"
        return 0
    fi

    fallback
}

main "$@"
